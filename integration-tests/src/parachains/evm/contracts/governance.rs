use super::*;

lazy_static! {
    pub(crate) static ref GOVERNANCE_CONTRACT_ADDRESS: Address =
        address_of("3ed62137c5db927cb137c26455969116bf0c23cb");
}

// bytecode:object value from ParachainGovernance.json, generated by forge build
const CONTRACT_BYTECODE: [u8; 10869] = {
    with_builtin!(let $hex_str = include_str_from_root!("contracts/ParachainGovernance.hex") in {
        hex!($hex_str)
    })
};

pub(crate) fn deploy(registry: Address, team_multisig: Address) {
    // use contract bytecode + constructor parameters
    let mut init = CONTRACT_BYTECODE.to_vec();
    init.append(
        encode(&vec![
            Token::Address(registry),
            Token::Address(team_multisig),
        ])
        .as_mut(),
    );

    // create parachain governance contract
    assert_ok!(EVM::create(
        RuntimeOrigin::root(),
        *ALITH,
        init,
        U256::zero(),
        GAS_LIMIT,
        MAX_FEE_PER_GAS.into(),
        None,
        None,
        Vec::new()
    ));
    System::assert_last_event(
        pallet_evm::Event::Created {
            address: *GOVERNANCE_CONTRACT_ADDRESS,
        }
        .into(),
    );
}

pub(crate) fn init(staking: Address) {
    #[allow(deprecated)]
    let input = Function {
        name: "init".to_string(),
        inputs: vec![Param {
            name: "_parachainStaking".to_string(),
            kind: ParamType::Address,
            internal_type: None,
        }],
        outputs: vec![],
        constant: None,
        state_mutability: Default::default(),
    }
    .encode_input(&vec![Token::Address(staking)])
    .unwrap();

    // init parachain governance contract
    assert_ok!(EVM::call(
        RuntimeOrigin::root(),
        *ALITH,
        *GOVERNANCE_CONTRACT_ADDRESS,
        input,
        U256::zero(),
        GAS_LIMIT,
        MAX_FEE_PER_GAS.into(),
        None,
        None,
        Vec::new()
    ));
    System::assert_has_event(
        pallet_evm::Event::Executed {
            address: *GOVERNANCE_CONTRACT_ADDRESS,
        }
        .into(),
    );
}

pub(crate) fn tally_votes(source: Address, dispute_id: H256) {
    #[allow(deprecated)]
    let input = Function {
        name: "tallyVotes".to_string(),
        inputs: vec![Param {
            name: "_disputeId".to_string(),
            kind: ParamType::FixedBytes(32),
            internal_type: None,
        }],
        outputs: vec![],
        constant: None,
        state_mutability: Default::default(),
    }
    .encode_input(&vec![Token::FixedBytes(dispute_id.0.to_vec())])
    .unwrap();

    // call parachain governance contract
    assert_ok!(EVM::call(
        RuntimeOrigin::root(),
        source,
        *GOVERNANCE_CONTRACT_ADDRESS,
        input,
        U256::zero(),
        GAS_LIMIT,
        MAX_FEE_PER_GAS.into(),
        None,
        None,
        Vec::new()
    ));
    System::assert_has_event(
        pallet_evm::Event::Executed {
            address: *GOVERNANCE_CONTRACT_ADDRESS,
        }
        .into(),
    );
}

pub(crate) fn execute_vote(source: Address, dispute_id: H256) {
    #[allow(deprecated)]
    let input = Function {
        name: "executeVote".to_string(),
        inputs: vec![Param {
            name: "_disputeId".to_string(),
            kind: ParamType::FixedBytes(32),
            internal_type: None,
        }],
        outputs: vec![],
        constant: None,
        state_mutability: Default::default(),
    }
    .encode_input(&vec![Token::FixedBytes(dispute_id.0.to_vec())])
    .unwrap();

    // call parachain governance contract
    assert_ok!(EVM::call(
        RuntimeOrigin::root(),
        source,
        *GOVERNANCE_CONTRACT_ADDRESS,
        input,
        U256::zero(),
        GAS_LIMIT,
        MAX_FEE_PER_GAS.into(),
        None,
        None,
        Vec::new()
    ));
    System::assert_has_event(
        pallet_evm::Event::Executed {
            address: *GOVERNANCE_CONTRACT_ADDRESS,
        }
        .into(),
    );
}

pub(crate) fn assert_executed(caller: Address) {
    assert!(System::events().iter().any(|r| {
        match &r.event {
            RuntimeEvent::Ethereum(pallet_ethereum::Event::Executed {
                from,
                to,
                exit_reason,
                ..
            }) if *from == caller
                && *to == *GOVERNANCE_CONTRACT_ADDRESS
                && *exit_reason == Succeed(Stopped) =>
            {
                true
            }
            _ => false,
        }
    }));
}

pub(crate) fn assert_new_parachain_dispute_event(
    para_id: impl Into<u32>,
    query_id: Vec<u8>,
    timestamp: u64,
    reporter: Address,
) {
    let event = Event {
        name: "NewParachainDispute".to_string(),
        inputs: vec![
            EventParam {
                name: "_paraId".to_string(),
                kind: ParamType::Uint(32),
                indexed: false,
            },
            EventParam {
                name: "_queryId".to_string(),
                kind: ParamType::FixedBytes(32),
                indexed: false,
            },
            EventParam {
                name: "_timestamp".to_string(),
                kind: ParamType::Uint(256),
                indexed: false,
            },
            EventParam {
                name: "_reporter".to_string(),
                kind: ParamType::Address,
                indexed: false,
            },
        ],
        anonymous: false,
    };

    System::assert_has_event(
        pallet_evm::Event::Log {
            log: ethereum::Log {
                address: *GOVERNANCE_CONTRACT_ADDRESS,
                topics: vec![event.signature()],
                data: encode(&vec![
                    Token::Uint(para_id.into().into()),
                    Token::FixedBytes(query_id),
                    Token::Uint(timestamp.into()),
                    Token::Address(reporter),
                ]),
            },
        }
        .into(),
    );
}

pub(crate) fn assert_parachain_voted_event(
    dispute_id: H256,
    total_tips_for: impl Into<U256>,
    total_tips_against: impl Into<U256>,
    total_tips_invalid: impl Into<U256>,
    total_reports_for: impl Into<U256>,
    total_reports_against: impl Into<U256>,
    total_reports_invalid: impl Into<U256>,
) {
    let event = Event {
        name: "ParachainVoted".to_string(),
        inputs: vec![
            EventParam {
                name: "_disputeId".to_string(),
                kind: ParamType::FixedBytes(32),
                indexed: false,
            },
            EventParam {
                name: "_totalTipsFor".to_string(),
                kind: ParamType::Uint(256),
                indexed: false,
            },
            EventParam {
                name: "_totalTipsAgainst".to_string(),
                kind: ParamType::Uint(256),
                indexed: false,
            },
            EventParam {
                name: "_totalTipsInvalid".to_string(),
                kind: ParamType::Uint(256),
                indexed: false,
            },
            EventParam {
                name: "_totalReportsFor".to_string(),
                kind: ParamType::Uint(256),
                indexed: false,
            },
            EventParam {
                name: "_totalReportsAgainst".to_string(),
                kind: ParamType::Uint(256),
                indexed: false,
            },
            EventParam {
                name: "_totalReportsInvalid".to_string(),
                kind: ParamType::Uint(256),
                indexed: false,
            },
        ],
        anonymous: false,
    };

    System::assert_has_event(
        pallet_evm::Event::Log {
            log: ethereum::Log {
                address: *GOVERNANCE_CONTRACT_ADDRESS,
                topics: vec![event.signature()],
                data: encode(&vec![
                    Token::FixedBytes(dispute_id.0.to_vec()),
                    Token::Uint(total_tips_for.into()),
                    Token::Uint(total_tips_against.into()),
                    Token::Uint(total_tips_invalid.into()),
                    Token::Uint(total_reports_for.into()),
                    Token::Uint(total_reports_against.into()),
                    Token::Uint(total_reports_invalid.into()),
                ]),
            },
        }
        .into(),
    );
}

pub(crate) fn assert_vote_tallied_event(
    dispute_id: H256,
    vote_result: u8,
    initiator: Address,
    reporter: Address,
) {
    let event = Event {
        name: "VoteTallied".to_string(),
        inputs: vec![
            EventParam {
                name: "_disputeId".to_string(),
                kind: ParamType::FixedBytes(32),
                indexed: false,
            },
            EventParam {
                name: "_result".to_string(),
                kind: ParamType::Uint(8),
                indexed: false,
            },
            EventParam {
                name: "_initiator".to_string(),
                kind: ParamType::Address,
                indexed: false,
            },
            EventParam {
                name: "_reporter".to_string(),
                kind: ParamType::Address,
                indexed: false,
            },
        ],
        anonymous: false,
    };

    System::assert_has_event(
        pallet_evm::Event::Log {
            log: ethereum::Log {
                address: *GOVERNANCE_CONTRACT_ADDRESS,
                topics: vec![event.signature()],
                data: encode(&vec![
                    Token::FixedBytes(dispute_id.0.to_vec()),
                    Token::Uint((vote_result as u8).into()),
                    Token::Address(initiator),
                    Token::Address(reporter),
                ]),
            },
        }
        .into(),
    );
}

pub(crate) fn assert_vote_executed_event(dispute_id: H256, vote_result: u8) {
    let event = Event {
        name: "VoteExecuted".to_string(),
        inputs: vec![
            EventParam {
                name: "_disputeId".to_string(),
                kind: ParamType::FixedBytes(32),
                indexed: false,
            },
            EventParam {
                name: "_result".to_string(),
                kind: ParamType::Uint(8),
                indexed: false,
            },
        ],
        anonymous: false,
    };

    System::assert_has_event(
        pallet_evm::Event::Log {
            log: ethereum::Log {
                address: *GOVERNANCE_CONTRACT_ADDRESS,
                topics: vec![event.signature()],
                data: encode(&vec![
                    Token::FixedBytes(dispute_id.0.to_vec()),
                    Token::Uint((vote_result as u8).into()),
                ]),
            },
        }
        .into(),
    );
}
