use super::*;
use moonbeam_runtime::Assets;

lazy_static! {
    pub(crate) static ref STAKING_CONTRACT_ADDRESS: Address =
        address_of("970951a12f975e6762482aca81e57d5a2a4e73f4");
}

// bytecode:object value from ParachainStaking.json, generated by forge build
const CONTRACT_BYTECODE: [u8; 9452] = {
    with_builtin!(let $hex_str = include_str_from_root!("contracts/ParachainStaking.hex") in {
        hex!($hex_str)
    })
};

pub(crate) fn deploy(registry: Address, token: Address) {
    // use contract bytecode + constructor parameters
    let mut init = CONTRACT_BYTECODE.to_vec();
    init.append(encode(&vec![Token::Address(registry), Token::Address(token)]).as_mut());

    // create parachain staking contract
    assert_ok!(EVM::create(
        RuntimeOrigin::root(),
        *ALITH,
        init,
        U256::zero(),
        GAS_LIMIT,
        MAX_FEE_PER_GAS.into(),
        None,
        None,
        Vec::new()
    ));
    System::assert_last_event(
        pallet_evm::Event::Created {
            address: *STAKING_CONTRACT_ADDRESS,
        }
        .into(),
    );
}

pub(crate) fn init(governance: Address) {
    #[allow(deprecated)]
    let input = Function {
        name: "init".to_string(),
        inputs: vec![Param {
            name: "_governanceAddress".to_string(),
            kind: ParamType::Address,
            internal_type: None,
        }],
        outputs: vec![],
        constant: None,
        state_mutability: Default::default(),
    }
    .encode_input(&vec![Token::Address(governance)])
    .unwrap();

    // init parachain staking contract
    assert_ok!(EVM::call(
        RuntimeOrigin::root(),
        *ALITH,
        *STAKING_CONTRACT_ADDRESS,
        input,
        U256::zero(),
        GAS_LIMIT,
        MAX_FEE_PER_GAS.into(),
        None,
        None,
        Vec::new()
    ));
    System::assert_has_event(
        pallet_evm::Event::Executed {
            address: *STAKING_CONTRACT_ADDRESS,
        }
        .into(),
    );
}

pub(crate) fn approve(by: impl Into<AccountId20>, asset: u128, delegate: Address, amount: u128) {
    assert_ok!(Assets::approve_transfer(
        RuntimeOrigin::signed(by.into()),
        asset.into(),
        delegate.into(),
        amount
    ));
    //todo: assert event
}

pub(crate) fn mint(asset: u128, who: impl Into<AccountId20>, amount: u128) {
    use frame_support::traits::fungibles::Mutate;

    assert_ok!(Assets::mint_into(asset, &who.into(), amount));
    //todo: assert event
}

pub(crate) fn deposit_parachain_stake(
    source: Address,
    para_id: impl Into<u32>,
    account: Vec<u8>,
    amount: u128,
) {
    #[allow(deprecated)]
    let input = Function {
        name: "depositParachainStake".to_string(),
        inputs: vec![
            Param {
                name: "_paraId".to_string(),
                kind: ParamType::Uint(32),
                internal_type: None,
            },
            Param {
                name: "_account".to_string(),
                kind: ParamType::Bytes,
                internal_type: None,
            },
            Param {
                name: "_amount".to_string(),
                kind: ParamType::Uint(256),
                internal_type: None,
            },
        ],
        outputs: vec![],
        constant: None,
        state_mutability: Default::default(),
    }
    .encode_input(&vec![
        Token::Uint(para_id.into().into()),
        Token::Bytes(account),
        Token::Uint(amount.into()),
    ])
    .unwrap();

    // call parachain staking contract
    assert_ok!(EVM::call(
        RuntimeOrigin::root(),
        source,
        *STAKING_CONTRACT_ADDRESS,
        input,
        U256::zero(),
        GAS_LIMIT,
        MAX_FEE_PER_GAS.into(),
        None,
        None,
        Vec::new()
    ));
    System::assert_has_event(
        pallet_evm::Event::Executed {
            address: *STAKING_CONTRACT_ADDRESS,
        }
        .into(),
    );
}

pub(crate) fn request_parachain_stake_withdraw(
    source: Address,
    para_id: impl Into<u32>,
    amount: u128,
) {
    #[allow(deprecated)]
    let input = Function {
        name: "requestParachainStakeWithdraw".to_string(),
        inputs: vec![
            Param {
                name: "_paraId".to_string(),
                kind: ParamType::Uint(32),
                internal_type: None,
            },
            Param {
                name: "_amount".to_string(),
                kind: ParamType::Uint(256),
                internal_type: None,
            },
        ],
        outputs: vec![],
        constant: None,
        state_mutability: Default::default(),
    }
    .encode_input(&vec![
        Token::Uint(para_id.into().into()),
        Token::Uint(amount.into()),
    ])
    .unwrap();

    // call parachain staking contract
    assert_ok!(EVM::call(
        RuntimeOrigin::root(),
        source,
        *STAKING_CONTRACT_ADDRESS,
        input,
        U256::zero(),
        GAS_LIMIT,
        MAX_FEE_PER_GAS.into(),
        None,
        None,
        Vec::new()
    ));
    System::assert_has_event(
        pallet_evm::Event::Executed {
            address: *STAKING_CONTRACT_ADDRESS,
        }
        .into(),
    );
}

pub(crate) fn withdraw_parachain_stake(source: Address, para_id: impl Into<u32>) {
    #[allow(deprecated)]
    let input = Function {
        name: "withdrawParachainStake".to_string(),
        inputs: vec![Param {
            name: "_paraId".to_string(),
            kind: ParamType::Uint(32),
            internal_type: None,
        }],
        outputs: vec![],
        constant: None,
        state_mutability: Default::default(),
    }
    .encode_input(&vec![Token::Uint(para_id.into().into())])
    .unwrap();

    // call parachain staking contract
    assert_ok!(EVM::call(
        RuntimeOrigin::root(),
        source,
        *STAKING_CONTRACT_ADDRESS,
        input,
        U256::zero(),
        GAS_LIMIT,
        MAX_FEE_PER_GAS.into(),
        None,
        None,
        Vec::new()
    ));
    System::assert_has_event(
        pallet_evm::Event::Executed {
            address: *STAKING_CONTRACT_ADDRESS,
        }
        .into(),
    );
}

pub(crate) fn assert_new_staker_event(staker: Address, amount: u128) {
    let event = Event {
        name: "NewStaker".to_string(),
        inputs: vec![
            EventParam {
                name: "_staker".to_string(),
                kind: ParamType::Address,
                indexed: true,
            },
            EventParam {
                name: "_amount".to_string(),
                kind: ParamType::Uint(256),
                indexed: true,
            },
        ],
        anonymous: false,
    };

    System::assert_has_event(
        pallet_evm::Event::Log {
            log: ethereum::Log {
                address: *STAKING_CONTRACT_ADDRESS,
                topics: vec![
                    event.signature(),
                    {
                        let mut topic = [0u8; 32];
                        topic[12..].clone_from_slice(&staker.0);
                        topic
                    }
                    .into(),
                    {
                        let topic: [u8; 32] = encode(&vec![Token::Uint(amount.into())])
                            .try_into()
                            .unwrap();
                        topic
                    }
                    .into(),
                ],
                data: Default::default(),
            },
        }
        .into(),
    );
}

pub(crate) fn assert_new_parachain_staker_event(
    para_id: impl Into<u32>,
    staker: Address,
    account: Vec<u8>,
    amount: u128,
) {
    let event = Event {
        name: "NewParachainStaker".to_string(),
        inputs: vec![
            EventParam {
                name: "_paraId".to_string(),
                kind: ParamType::Uint(32),
                indexed: false,
            },
            EventParam {
                name: "_staker".to_string(),
                kind: ParamType::Address,
                indexed: false,
            },
            EventParam {
                name: "_account".to_string(),
                kind: ParamType::Bytes,
                indexed: false,
            },
            EventParam {
                name: "_amount".to_string(),
                kind: ParamType::Uint(256),
                indexed: false,
            },
        ],
        anonymous: false,
    };

    System::assert_has_event(
        pallet_evm::Event::Log {
            log: ethereum::Log {
                address: *STAKING_CONTRACT_ADDRESS,
                topics: vec![event.signature()],
                data: encode(&vec![
                    Token::Uint(para_id.into().into()),
                    Token::Address(staker),
                    Token::Bytes(account),
                    Token::Uint(amount.into()),
                ]),
            },
        }
        .into(),
    );
}

pub(crate) fn assert_parachain_reporter_slashed_event(
    para_id: impl Into<u32>,
    reporter: Address,
    recipient: Address,
    slash_amount: u128,
) {
    let event = Event {
        name: "ParachainReporterSlashed".to_string(),
        inputs: vec![
            EventParam {
                name: "_paraId".to_string(),
                kind: ParamType::Uint(32),
                indexed: false,
            },
            EventParam {
                name: "_reporter".to_string(),
                kind: ParamType::Address,
                indexed: false,
            },
            EventParam {
                name: "_recipient".to_string(),
                kind: ParamType::Address,
                indexed: false,
            },
            EventParam {
                name: "_slashAmount".to_string(),
                kind: ParamType::Uint(256),
                indexed: false,
            },
        ],
        anonymous: false,
    };

    System::assert_has_event(
        pallet_evm::Event::Log {
            log: ethereum::Log {
                address: *STAKING_CONTRACT_ADDRESS,
                topics: vec![event.signature()],
                data: encode(&vec![
                    Token::Uint(para_id.into().into()),
                    Token::Address(reporter),
                    Token::Address(recipient),
                    Token::Uint(slash_amount.into()),
                ]),
            },
        }
        .into(),
    );
}

pub(crate) fn assert_stake_withdraw_requested_event(staker: Address, amount: u128) {
    let event = Event {
        name: "StakeWithdrawRequested".to_string(),
        inputs: vec![
            EventParam {
                name: "_staker".to_string(),
                kind: ParamType::Address,
                indexed: false,
            },
            EventParam {
                name: "_amount".to_string(),
                kind: ParamType::Uint(256),
                indexed: false,
            },
        ],
        anonymous: false,
    };

    System::assert_has_event(
        pallet_evm::Event::Log {
            log: ethereum::Log {
                address: *STAKING_CONTRACT_ADDRESS,
                topics: vec![event.signature()],
                data: encode(&vec![Token::Address(staker), Token::Uint(amount.into())]),
            },
        }
        .into(),
    );
}

pub(crate) fn assert_parachain_stake_withdraw_requested_event(
    para_id: impl Into<u32>,
    account: Vec<u8>,
    amount: u128,
) {
    let event = Event {
        name: "ParachainStakeWithdrawRequested".to_string(),
        inputs: vec![
            EventParam {
                name: "_paraId".to_string(),
                kind: ParamType::Uint(32),
                indexed: false,
            },
            EventParam {
                name: "_account".to_string(),
                kind: ParamType::Bytes,
                indexed: false,
            },
            EventParam {
                name: "_amount".to_string(),
                kind: ParamType::Uint(256),
                indexed: false,
            },
        ],
        anonymous: false,
    };

    System::assert_has_event(
        pallet_evm::Event::Log {
            log: ethereum::Log {
                address: *STAKING_CONTRACT_ADDRESS,
                topics: vec![event.signature()],
                data: encode(&vec![
                    Token::Uint(para_id.into().into()),
                    Token::Bytes(account),
                    Token::Uint(amount.into()),
                ]),
            },
        }
        .into(),
    );
}

pub(crate) fn assert_stake_withdrawn_event(staker: Address) {
    let event = Event {
        name: "StakeWithdrawn".to_string(),
        inputs: vec![EventParam {
            name: "_staker".to_string(),
            kind: ParamType::Address,
            indexed: false,
        }],
        anonymous: false,
    };

    System::assert_has_event(
        pallet_evm::Event::Log {
            log: ethereum::Log {
                address: *STAKING_CONTRACT_ADDRESS,
                topics: vec![event.signature()],
                data: encode(&vec![Token::Address(staker)]),
            },
        }
        .into(),
    );
}

pub(crate) fn assert_parachain_stake_withdrawn_event(para_id: impl Into<u32>, staker: Address) {
    let event = Event {
        name: "ParachainStakeWithdrawn".to_string(),
        inputs: vec![
            EventParam {
                name: "_paraId".to_string(),
                kind: ParamType::Uint(32),
                indexed: false,
            },
            EventParam {
                name: "_staker".to_string(),
                kind: ParamType::Address,
                indexed: false,
            },
        ],
        anonymous: false,
    };

    System::assert_has_event(
        pallet_evm::Event::Log {
            log: ethereum::Log {
                address: *STAKING_CONTRACT_ADDRESS,
                topics: vec![event.signature()],
                data: encode(&vec![
                    Token::Uint(para_id.into().into()),
                    Token::Address(staker),
                ]),
            },
        }
        .into(),
    );
}
